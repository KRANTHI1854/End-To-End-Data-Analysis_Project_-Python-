-- SUPERSTORE SQL ANALYTICS PROJECT
-- Done by: kranthi Kumar srimanthula (Aspiring Data Analyst)
-- Using Database: superstore | Table: cleaned_superstore_data

-- =====================================================
-- PHASE 1: DATA UNDERSTANDING & STRUCTURE
-- =====================================================

-- Start by selecting the correct database
USE superstore;

-- Preview first 10 records to get a feel for the data
SELECT * FROM cleaned_superstore_data LIMIT 10;

-- View all columns and their data types
DESCRIBE cleaned_superstore_data;

-- Get total number of records in the table
SELECT COUNT(*) AS total_records FROM cleaned_superstore_data;

-- Count how many unique customers are in the data
SELECT COUNT(DISTINCT customer_id) AS unique_customers FROM cleaned_superstore_data;

-- Count of different products sold
SELECT COUNT(DISTINCT product_name) AS unique_products FROM cleaned_superstore_data;

-- Number of cities and regions in dataset
SELECT COUNT(DISTINCT city) AS unique_cities, COUNT(DISTINCT region) AS unique_regions FROM cleaned_superstore_data;

-- Time range: find the earliest and latest order dates
SELECT MIN(order_date) AS earliest_order, MAX(order_date) AS latest_order FROM cleaned_superstore_data;

-- Orders placed per year to understand yearly distribution
SELECT order_year, COUNT(DISTINCT order_id) AS total_orders FROM cleaned_superstore_data GROUP BY order_year;

-- Top 5 customers by number of orders (engagement level)
SELECT customer_id, customer_name, COUNT(DISTINCT order_id) AS order_count
FROM cleaned_superstore_data
GROUP BY customer_id, customer_name
ORDER BY order_count DESC
LIMIT 5;

-- =====================================================
-- PHASE 2: DATA CLEANING CHECKS
-- =====================================================

-- Check for missing values in important columns
SELECT 
    SUM(CASE WHEN sales IS NULL THEN 1 ELSE 0 END) AS null_sales,
    SUM(CASE WHEN profit IS NULL THEN 1 ELSE 0 END) AS null_profit,
    SUM(CASE WHEN order_date IS NULL THEN 1 ELSE 0 END) AS null_order_date
FROM cleaned_superstore_data;

-- Check if any rows are exact duplicates
SELECT COUNT(*) - COUNT(DISTINCT CONCAT_WS('-', row_id, order_id, product_name, sales, profit)) AS duplicate_rows
FROM cleaned_superstore_data;

-- Check for empty or blank customer names (invalid entry)
SELECT COUNT(*) AS blank_customers
FROM cleaned_superstore_data
WHERE TRIM(customer_name) = '';

-- Find rows where shipment happened before order (data issue)
SELECT * 
FROM cleaned_superstore_data 
WHERE ship_date < order_date;

-- Identify rows with zero or negative sales/quantity
SELECT * 
FROM cleaned_superstore_data 
WHERE sales <= 0 OR quantity <= 0;

-- Identify orders dated in the future (incorrect entry)
SELECT * 
FROM cleaned_superstore_data 
WHERE order_date > CURDATE();

-- =====================================================
-- PHASE 3: DESCRIPTIVE BUSINESS METRICS
-- =====================================================

-- Total sales and profit generated by the business
SELECT ROUND(SUM(sales), 2) AS total_sales, ROUND(SUM(profit), 2) AS total_profit
FROM cleaned_superstore_data;

-- Calculate Average Order Value (AOV)
SELECT ROUND(SUM(sales) / COUNT(DISTINCT order_id), 2) AS avg_order_value
FROM cleaned_superstore_data;

-- Total quantity of products sold
SELECT SUM(quantity) AS total_quantity FROM cleaned_superstore_data;

-- Total distinct orders in dataset
SELECT COUNT(DISTINCT order_id) AS total_orders FROM cleaned_superstore_data;

-- Overall profit margin across all sales
SELECT ROUND(SUM(profit) * 100 / SUM(sales), 2) AS overall_profit_margin
FROM cleaned_superstore_data;

-- Category-wise total sales, profit, and profit margin
SELECT category, 
       ROUND(SUM(sales), 2) AS total_sales, 
       ROUND(SUM(profit), 2) AS total_profit,
       ROUND(SUM(profit)*100/SUM(sales), 2) AS profit_margin
FROM cleaned_superstore_data
GROUP BY category;

-- Region-wise total sales and profit
SELECT region, 
       SUM(sales) AS sales, 
       SUM(profit) AS profit
FROM cleaned_superstore_data
GROUP BY region;

-- =====================================================
-- PHASE 4: TIME-BASED TRENDS
-- =====================================================

-- Annual sales trend
SELECT order_year, SUM(sales) AS total_sales
FROM cleaned_superstore_data
GROUP BY order_year
ORDER BY order_year;

-- Total sales by month across all years (seasonality)
SELECT order_month, SUM(sales) AS monthly_sales
FROM cleaned_superstore_data
GROUP BY order_month
ORDER BY order_month;

-- Sales by year and month (for trendline plotting)
SELECT order_year, order_month, SUM(sales) AS monthly_sales
FROM cleaned_superstore_data
GROUP BY order_year, order_month
ORDER BY order_year, order_month;

-- Daily-level sales trend over time
SELECT order_date, SUM(sales) AS daily_sales
FROM cleaned_superstore_data
GROUP BY order_date
ORDER BY order_date;

-- Profit margin trend by year
SELECT order_year,
       ROUND(SUM(profit)*100 / SUM(sales), 2) AS profit_margin_pct
FROM cleaned_superstore_data
GROUP BY order_year;

-- =====================================================
-- PHASE 5: CUSTOMER INSIGHTS
-- =====================================================

-- Number of customers by segment
SELECT segment, COUNT(DISTINCT customer_id) AS customers
FROM cleaned_superstore_data
GROUP BY segment;

-- Average customer lifetime value (CLTV estimate)
SELECT ROUND(SUM(sales)/COUNT(DISTINCT customer_id), 2) AS avg_sales_per_customer
FROM cleaned_superstore_data;

-- Top 5 customers by total money spent
SELECT customer_id, customer_name, ROUND(SUM(sales), 2) AS total_spent
FROM cleaned_superstore_data
GROUP BY customer_id, customer_name
ORDER BY total_spent DESC
LIMIT 5;

-- Top 5 customers by number of orders
SELECT customer_id, COUNT(DISTINCT order_id) AS order_count
FROM cleaned_superstore_data
GROUP BY customer_id
ORDER BY order_count DESC
LIMIT 5;

-- Classify new vs repeat customers using order counts
WITH customer_orders AS (
    SELECT customer_id, COUNT(DISTINCT order_id) AS num_orders
    FROM cleaned_superstore_data
    GROUP BY customer_id
)
SELECT 
    SUM(CASE WHEN num_orders = 1 THEN 1 ELSE 0 END) AS new_customers,
    SUM(CASE WHEN num_orders > 1 THEN 1 ELSE 0 END) AS repeat_customers
FROM customer_orders;

-- =====================================================
-- PHASE 6: PRODUCT & CATEGORY PERFORMANCE
-- =====================================================

-- Total sales and profit by category
SELECT category, SUM(sales) AS sales, SUM(profit) AS profit
FROM cleaned_superstore_data
GROUP BY category;

-- Sales by sub-category
SELECT `sub-category` AS sub_category, SUM(sales) AS total_sales
FROM cleaned_superstore_data
GROUP BY `sub-category`
LIMIT 0, 1000;

-- Sub-categories with highest total profit
SELECT `sub-category` AS sub_category, SUM(profit) AS total_profit
FROM cleaned_superstore_data
GROUP BY sub_category
ORDER BY total_profit DESC;

-- Top 5 best-selling products
SELECT product_name, SUM(sales) AS sales
FROM cleaned_superstore_data
GROUP BY product_name
ORDER BY sales DESC
LIMIT 5;

-- Top 5 most profitable products
SELECT product_name, SUM(profit) AS profit
FROM cleaned_superstore_data
GROUP BY product_name
ORDER BY profit DESC
LIMIT 5;

-- =====================================================
-- PHASE 7: PROFIT & LOSS ANALYSIS
-- =====================================================

-- Count of loss-making transactions
SELECT COUNT(*) AS loss_orders
FROM cleaned_superstore_data
WHERE profit < 0;

-- What % of orders are unprofitable
SELECT 
    ROUND(SUM(CASE WHEN profit < 0 THEN 1 ELSE 0 END)*100 / COUNT(*), 2) AS loss_percentage
FROM cleaned_superstore_data;

-- Top 5 products causing most loss
SELECT product_name, SUM(profit) AS total_loss
FROM cleaned_superstore_data
WHERE profit < 0
GROUP BY product_name
ORDER BY total_loss ASC
LIMIT 5;

-- Sub-categories with overall negative profit
SELECT `sub-category` AS sub_category,
SUM(profit) AS total_profit
FROM cleaned_superstore_data
GROUP BY `sub-category`
HAVING total_profit < 0
ORDER BY total_profit ASC;

-- =====================================================
-- PHASE 8: SHIPPING & DELIVERY BEHAVIOR
-- =====================================================

-- Total number of unique shipping modes
SELECT COUNT(DISTINCT ship_mode) AS shipping_modes
FROM cleaned_superstore_data;

-- Orders by shipping mode
SELECT ship_mode, COUNT(DISTINCT order_id) AS order_count
FROM cleaned_superstore_data
GROUP BY ship_mode;

-- Calculate average shipping delay (days between order and ship)
SELECT ROUND(AVG(DATEDIFF(ship_date, order_date)), 2) AS avg_shipping_days
FROM cleaned_superstore_data;

-- Average shipping delay by shipping mode
SELECT ship_mode, ROUND(AVG(DATEDIFF(ship_date, order_date)), 2) AS avg_days
FROM cleaned_superstore_data
GROUP BY ship_mode;

-- Shipping delays by region
SELECT region, ROUND(AVG(DATEDIFF(ship_date, order_date)), 2) AS avg_delay
FROM cleaned_superstore_data
GROUP BY region;

-- =====================================================
-- PHASE 9: ADVANCED SQL (CTEs, WINDOWS)
-- =====================================================

-- CTE: Rank top 3 sub-categories by sales in each year
WITH ranked_subs AS (
    SELECT `sub-category` AS sub_category, order_year, SUM(sales) AS total_sales,
           RANK() OVER (PARTITION BY order_year ORDER BY SUM(sales) DESC) AS rank_in_year
    FROM cleaned_superstore_data
    GROUP BY `sub-category`, order_year
)
SELECT * FROM ranked_subs
WHERE rank_in_year <= 3;

-- Window Function: Running total of sales over time
SELECT order_date, 
       SUM(sales) OVER (ORDER BY order_date) AS running_total_sales
FROM cleaned_superstore_data;


-- Window: Dense rank of categories based on total profit
SELECT category, 
       SUM(profit) AS total_profit,
       DENSE_RANK() OVER (ORDER BY SUM(profit) DESC) AS rank_by_profit
FROM cleaned_superstore_data
GROUP BY category;


